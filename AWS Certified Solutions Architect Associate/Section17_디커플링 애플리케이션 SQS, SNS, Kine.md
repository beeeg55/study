# Section17. 디커플링 애플리케이션: SQS, SNS, Kinesis, Active MQ

Date: June 11, 2023

커뮤니케이션 유형

- 동기 커뮤니케이션 - 직접 연결
- 비동기 or 이벤트 기반 커뮤니케이션 - 대기열이 연결해줌

한 서비스가 다른 서비스를 압도하는경우(한쪽 트래픽이 너무 많은경우 분리 필요)

- 대기열 유형 - 확장에 용이
    - SQS
    - SNS
    - Kinesis

- SQS
    - 대기 서비스
    - SQS queue에는 메세지를 포함
    - 생산자는 sqs queue에 메세지를 보냄
    - 애플리케이션 간의 분리를 위해 사용
    - SQS - Standard Queue
        - 가장 오래된 서비스
        - 완전관리형 서비스로 애플리케이션을 분리하는데 사용(분리하여 각자 서비스에 맞는 ec2선택 등을 할 수 있는 장점)
        - 무제한 처리량 가능, 초당 원하는 만큼 메세지를 보낼 수 있고 대기열 메세지 수에도 제한이 없다
        - 메세지는 수명이 짧음(1분~14일. 기본 4일)
        - 메세지를 읽고 시간내 처리하지않으면 소실
        - 지연시간이 짧음 10밀리초내로 빠르게 응답
        - 메세지는 작아야함 (256kb 미만)
        - 높은 처리량, 높은 볼륨 등이 있어서 중복 메시지가 있을 수 있다
        - 품절 메세지를 보낼 수 있음
        - 생산자 관점
        1. 생산자가 queue에 메세지 보냄 - sdk(sendmessage api) 사용
        2. 큐는 메세지가 삭제될때까지 유지(삭제 = 메시지가 처리됐다)
        - 소비자 관점
        1. 애플리케이션 코드 작성 - ec2 instance, 서버,람다 등 
        2. 소비자는 메시지를 폴링(최대 10개) 
        - 본인이 빨리 처리하지않으면 또 보게됨, 적어도 한번은 전달
        - 수평확장으로 개수 늘릴수있음(asg 사용)
            - queue 메세지 개수를 cloudwatch가 보고있다가 asg에 알람을 줘서 asg 확장
        1. 자신에게 유효한 메시지가 있으면 처리
        2. delete message api로 대기열에서 메세지를 삭제(메세지 처리 완료)
    - SQS - FIFO Queue
        - 생산자에게 받은 순서대로 소비자에게 순서 유지해서 poll
        - 처리량에 제한(묶음 아닐경우 초당 300개, 묶음의 경우 초당 3000개)
        - 중복 제거 기능 - 정확히 한번만 보내기 가능
        - 소비자에 의해 순서대로 처리
        - 이름에 .fifo를 붙여야함

- SQS 보안
    - https api
    - kms key
    - 클라이언트 측 암호화
    - iam 정책
    - sqs access 정책(s3 버킷 정책과 비슷)
        - 교차 계정 접근을 원하는 경우
        - sns, s3 등 다른 서비스가 sqs 대기열을 쓸 수 있도록 함
        
- SQS - message visibility timeout
    - 소비자가 메세지를 폴링하면 그 메세지를 다른 소비자에게 안보여줌
    - 기본적으로 30초로 설정 ( 이 시간동안은 다른 소비자에게 보이지 않는다)
    - 메세지 처리중이나 timeout 시간보다 오래걸릴것 같은경우에는 소비자는 changemessagevisibility api호출하여 sqs에 알림

- SQL - long polling
    - 소비자가 대기열에 메시지를 요청하는데 메세지가 없는경우 정한 시간(1-20초) 만큼 기다리는것
        - 지연시간을 줄일 수 있음
        - SQS 로 보내는 api 호출 숫자를 줄일 수 있음
    - 구성방법 1. queue 레벨에서 구성 - 폴링하는 모든 소비자에게 활성화
    - 방법2. waittimesecond를 지정함으로써 소비자가 스스로 롤 폴링을 하도록 설정
    
- SQS WITH ASG
    - asg내의 인스턴스에 메시지를 sqs에서 폴링
    - cloudwatch의 지표는 대기열의 길이
        - approximatenumberofmessages를 사용하여 확인
    - 일정량보다 많은/적은 경우 cloud watch alarm → asg scale
    - 사례 : 광고, 이벤트 , 디비에서 buffer로 사용(queue까지는 처리량이 무한이기 때문에 유실되지 않도록 저장 후 db 쓰기 작업 수행)
        - 애플리케이션이 다시 뒷단처리에 대한 응답을 받지 않아도 되는경우에 사용

- amazon sns
    - pubs/sub 패턴
        - 메세지를 주제로 sns에 게시
        - 해당 주제에는 구독자들이 있음 - 구독자들은 구독중 해당 메세지를 보관 가능
    - 이벤트 생산자는 한 sns 주제에만 메시지를 보냄
    - 이벤트 수신자/구독자 : 해당 주제에 대한 sns 알림을 받으려는 사람
    - 주제별로 최대 1200만 이상의 구독자까지 가능
    - 계정당 가질 수 있는 주제수는 최대 10만개
    - 게시 : 이메일, sms, 휴대폰 알림, http엔드포인트 데이터 보낼 수 있음, sqs queue, lambda, kinesis
    - asg, cloudwatch alarms, lambda가 sns로 보내기도 함
    - sns 게시 방법
        - (sdk 사용해서) 주제 게시
            - 주제 만듬
            - 여러개 구독 만듬
            - sns 주제 게시
        - (모바일 앱 sdk 사용해서) 직접 게시 방법
            - 플랫폼 애플리케이션 만들기
            - 플랫폼 엔드 포인트 만들기
            - 엔드포인트에 게시
            - 수신가능 대상 : google, gpm, apns
    - 보안 측면에서 sqs와 동일
        - https api
        - kms key
        - 클라이언트 측 암호화
        - iam 정책
        - sns access polices
            - 교차 계정
            - 다른 서비스에서 sns 하고싶은경우
            
- SNS + SQS : FAN OUT 패턴
    - sns 주제에 메시지를 전송한 후 원하는 수의 sqs 대기열이 이 주제를 구독
    - 대기열들은 sns로 들어오는 모든 메세지를 받게됨
    - SQS 액세스 정책에서 sns 주제가 대기열에 쓰기 작업을 할 수 있도록 허용해야함
    - 리전간 전달 가능
    - Kinesis data firehose 를 통해 SNS TO S3 or kdf 목적지
    - sns는 fifo 기능 있음
        - 중복 제거 가능
        - 처리량 제한적
        - sqs fifo를 활용하려 팬아웃을 수행하려면 팬아웃, 순서, 중복 제거 필요
    - 메시지 필터링
        - sns 주제 구독 시 전송되는 메시지를 필터링하는데 사용되는 json 정책
        
- keneis
    - 실시간 스트리밍 데이터를 손쉽게 수집하고 처리하여 분석 가능
        - 실시간 데이터: 애플리케이션 로그, 계측, 웹 사이트 클릭스트림, iot 원격 측정 데이터 등
    - 네가지 서비스로 구성
        - kenesis data stream : 데이터 스트림을 수집하여 처리하여 저장
            - 시스템에서 큰 규모의 데이터 흐름을 다루는 서비스
            - 여러개의 샤드로 구성(사용자가 개수 지정)
            - 샤드에 데이터 분배
            - 보존기간 : 1-365일동안 데이터 다시 처리가능
            - 데이터가 kenesis로 들어오면 삭제 불가(불변성)
            - 데이터 스트림으로 데이터를 전송하면 파티션 키가 추가
                - 파티션키 같으면 샤드도 같음
            - 생산자 종류 : sdk, kinesis producer library(kpl), kenesis agent
            - 소비자 종류
                - 본인 작성 : kinesis client library(kcl), aws sdk
                - aws 관리 : lambda, kinesis data firehose, kinesis data analytics
            - 2가지 용량 유형
                - 프로비저닝 모드
                    - 프로비저닝할 샤드 수를 정하고 api를 활용하거나 수동으로 조정
                    - 각 샤드는 초당 1mb나 1천개의 레코드를 받아들임
                    - 출력의 경우에는 각 샤드가 초당 2mb 가능 (팬아웃 방식 적용 가능)
                    - 샤드를 프로비저닝 할때마다 시간당 비용 부과
                    - 사용량 예측 불가한 경우 사용
                - 온디맨드 몯
                    - 시간에 따라 용량 조정
                    - 초당 4mb, 4000레코드 가능
                    - 지난 30일동안 관측한 최대 처리량에 기반하여 자동으로 조정
                    - 시간당 스트림 당 송수신 데이터양에 따라 비용 부과
                    - 사용량이 예측 불가한 경우 사용
            - 보안
                - iam 정책 사용하여 샤드 생성, 읽기 권한 제어
                - https
                - 미사용 데이터 kms로 암호화
                - 클라이언트측 암호화
                - VPC 엔드포인트 사용 가능
                - cloudtrail로 감시 가능
        - kenesis data firehose: 데이터 스트림을 aws 내부나 외부의 데이터 저장소로 읽어들임
            - 생산자에서 데이터를 가져올 수 있는 유용한 서비스
            - 완전관리 서비스 : 자동용량크기조정, 서버리스
            - 수신처
                - aws : redshift(s3에서 카피), amazon s3, elasticsearch
                - 3rd party : splunk, mongodb, datadog, newrelic
                - custom : http endpoint
            - 비용지불 : 통과하는 데이터에 대해서만
            - 거의 실시간
                - 수신처로 데이터를 배치로 씀
                - 전체 배치가 아닌경우 최소 60초의 지연시간 발생
                - 데이터를 수신처러 보낼때 한번에 적어도 1mb의 데이터가 있을때까지 기다려야함
            - 여러 데이터 형식과 데이터 전환, 변환 압축 지원
            - 람다를 활용해 입력전 자체적인 데이터 변환 가능
            - 실패 혹은 모든 데이터를 백업 s3 버킷에 보낼 수 있다
        - kenesis data analytics : sql언어나 apache flink를 활용하여 데이터 스트림을 분석
        - kenesis video stream : 비디오 스트림을 수집하고 처리하여 저장
    - Kinesis data streams vs firehose
        - Kinesis data streams
            - 대규모로 수집할때 쓰는 스트리밍 서비스
            - 생산자와 소비자에 대해 커스텀 코드를 쓸 수 있음
            - 실시간
            - 샤드를통해 스케일 조정 가능
            - 샤드 수에 따라 비용지불
            - 1-365일간 데이터 저장
            - 여러 소비자가 같은 스트림에서 읽어올 수 있고 반복 기능 지원
        - kinesis data firehose
            - s3,redshift, http, 3rd 로 데이터 보낼때 사용
            - 근실시간
            - 자동 용량 조정
            - 지나간 데이터에만 비용 지불
            - 데이터 스토리지가 없어 데이터를 반복 가능 불가
    
- kinesis vs sqs
    - 가정 : 100개 트럭, 5개 kenesis 샤드, 1 sqs fifo
    - kenesis → 많은데이터를 받고 샤드당 데이터를 정렬할때
        - 하나의 샤드 당 20개 트럭
        - 각 샤드마다 정렬
        - 최대 5개 소비자 정렬
        - 최대 5mb 받음
    - sqs fifo → 그룹 id 숫자에 따른 동적 소비자 수를 원할때
        - 1개의 queue 가짐
        - 100개 group id 가짐
        - 100개 소비자까지 가질 수 있음
        - 300 message 초당
- SQS VS SNS VS KINESIS
    - SQS
        - 소비자가 sqs 대기열에서 메시지를 요청해서 데이터를 가져오는 모델
        - 작업자 소비자 제한 없음
        - 관리된 서비스 - 처리량 프로비저닝 할 필요 x (자동 확장)
        - 순서보장 원할시 fifo
        - 메시지 지연기능
    - SNS
        - 게시 구독 모델 - 다수의 구독자에게 데이터를 푸시하면 메시지의 복사본을 받게됨
        - 주제 별로 1250 만 명의 구독자까지 가능
        - 데이터가 한번 전송되면 지속되지 않음(잃을 가능성도 있게됨)
        - 최대 10만개 주제
        - 프로비저닝 필요 x
        - sqs 와 결합가능 - 1. 팬아웃아키텍처 2.fifo queue + fifo title
    - kinesis
        - standard 유형 : pull data
            - 샤드당 2mb 속도 지원
        - 팬아웃 유형 : push data
            - 샤드 하나에 소비자당 2mb 속도 지원
        - 더많은 데이터 읽기 가능
        - 데이터 다시 읽기가능
        - 실시간 빅데이터 분석 , etl 에 활용
        - 샤드레벨에서 원하는 샤드 양 지정
        - 샤드에 데이터 보관기간 정해야함
        - 프로비전 모드 or 온디맨드 모드(미리 지정 or 자동)
    
- amazon mq
    - 온프레미스에서 기존 애플리케이션을 실행하는 경우 개방형 프로토콜인 MQTT, AMQP, STOMP, WSS Opensire 등을 사용
    - 애플리케이션을 클라우드에 마이그레이션하는 경우에 sns, sqs를 위한 재작업이 필요없도록 mq를 사용
    - rabbitmq 와 activemq 두가지 기술(온프레미스기술로 개방형 프로토콜 액세스 지원)을 위한 관리형 메시지 브로커 서비스
    - 확장성이 크지 않음
    - 서버에서 실행되므로 서버 문제가 있을 수 있음 → 장애조치(EFS - 다른리전에 접근 가능)와 다중 az 설정(standby mq를 다른리전에 띄워둠)을 실행 가능
    - 대기열기능 (sqs 와 비슷), 주제 기능(sns와 비슷)
    -